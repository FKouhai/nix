{ config, pkgs, ... }:

{

  # Shared developer tooling for all hosts: Docker, libvirtd, Portainer
  virtualisation = {
    docker = {
      enable = true;
      enableOnBoot = true;
      # Optional: Expose socket for remote (secure with Tailscale ACLs)
      # socketBinding = "tcp://127.0.0.1:2375";  # Bind to localhost or Tailscale IP
    };
    libvirtd = {
      enable = true;
      qemu = {
        ovmf.enable = true;  # For UEFI VMs
        runAsRoot = false;
      };
    };
    oci-containers = {
      # backend = "docker"  # Use Docker backend
      containers = {
        "portainer" = {
            image = "portainer/portainer-ce:latest";
            ports = [ "9000:9000" ];
            volumes = [
              "/var/run/docker.sock:/var/run/docker.sock"
              "/var/lib/portainer:/data"  # Persistent data
            ];
            environment = {
              TZ = "America/New_York";  # Match host timezone
            };
            autoStart = true;
          };
        "code-server" = {
            image = "codercom/code-server:latest";
            ports = [ "8080:8080" ];
            volumes = [
              "/var/run/docker.sock:/var/run/docker.sock"
              "/var/lib/code-server:/home/coder/.config/code-server"  # Persistent config
              "/home/warby/Workspace:/home/coder/workspace"  # Workspace
              "/var/lib/code-server-certs:/certs"  # SSL certificates
            ];
            environment = {
              PASSWORD = "devsandbox123";  # Secure password for sandbox access
              TZ = "America/New_York";
              CERT_FILE = "/certs/cert.pem";
              KEY_FILE = "/certs/key.pem";
            };
            user = "1000";  # Run as coder user (uid 1000)
            cmd = [ "--bind-addr" "0.0.0.0" "--port" "8080" "--cert" "/certs/cert.pem" "--cert-key" "/certs/key.pem" ];
            autoStart = true;
          };
        };

    };
  };
    libvirtd = {
      enable = true;
      qemu = {
        ovmf.enable = true;  # For UEFI VMs
        runAsRoot = false;
      };
    };
    oci-containers = {
      # backend = "docker"  # Use Docker backend
      containers = {
        "portainer" = {
            image = "portainer/portainer-ce:latest";
            ports = [ "9000:9000" ];
            volumes = [
              "/var/run/docker.sock:/var/run/docker.sock"
              "/var/lib/portainer:/data"  # Persistent data
            ];
            environment = {
              TZ = "America/New_York";  # Match host timezone
            };
            autoStart = true;
          };
        "code-server" = {
            image = "codercom/code-server:latest";
            ports = [ "8080:8080" ];
            volumes = [
              "/var/run/docker.sock:/var/run/docker.sock"
              "/var/lib/code-server:/home/coder/.config/code-server"  # Persistent config
              "/home/warby/dev-sandbox:/home/coder/project"  # Sandbox workspace
              "${codeServerCerts}:/certs"  # SSL certificates from Nix store
            ];
            environment = {
              PASSWORD = "devsandbox123";  # Secure password for sandbox access
              TZ = "America/New_York";
              CERT_FILE = "/certs/cert.pem";
              KEY_FILE = "/certs/key.pem";
            };
            user = "1000";  # Run as coder user (uid 1000)
            entrypoint = "sh";
            cmd = [ "-c" "code-server --bind-addr 0.0.0.0:8080 --cert /certs/cert.pem --cert-key /certs/key.pem" ];
            autoStart = true;
          };
        };

    };
  };

  networking.firewall.interfaces."tailscale0".allowedTCPPorts = [ 9000 8080 ];

  # System packages for dev (docker-compose, etc.)
  environment.systemPackages = with pkgs; [
    docker-compose
    lazydocker
    virt-manager  # For libvirt GUI if needed

    # Elixir and Phoenix development
    elixir
    nodejs
    postgresql
  ];

  # Generic groups; add users per-host
  users.groups.libvirtd.members = [ ];  # Populate per-host
  users.groups.docker.members = [ ];    # Populate per-host
}
